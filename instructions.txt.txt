FIN-GUARD-AI BACKEND DEVELOPMENT
================================

PROJECT STATUS
--------------
- Frontend: 100% complete (Next.js + TypeScript + Tailwind)
- Firebase: Configured (Auth + Firestore working)
- Current: All dashboards use mock data
- GOAL: Replace mock data with real Firebase data + working Cloud Functions

YOUR MISSION
------------
1. Build Python Cloud Functions (4 functions)
2. Create Firestore data hooks (replace mock data)
3. Implement real-time risk scoring
4. Deploy and test end-to-end

ANTIGRAVITY SETUP
-----------------
1. Go to https://antigravity.ai or your provided URL
2. Create new project: "finguard-backend"
3. Connect to Firebase:
   - Project ID: finguard-ai-55aec
   - Service account: Download from Firebase Console â†’ Project settings â†’ Service accounts â†’ Generate new private key
   - Upload JSON key to Antigravity secrets
4. Runtime: Python 3.11

FIREBASE CONFIG (Already in frontend)
-------------------------------------
apiKey: AIzaSyBJfoqX_5ghf0Ggqv8cfjUJwP8ar5zptuU
authDomain: finguard-ai-55aec.firebaseapp.com
projectId: finguard-ai-55aec
storageBucket: finguard-ai-55aec.firebasestorage.app

CLOUD FUNCTIONS (4 Total)
=========================

FUNCTION 1: on_transaction_create (TRIGGER)
-------------------------------------------
Path: functions/src/triggers/on_transaction_create.py
Trigger: Firestore onCreate on users/{userId}/transactions/{txId}

WHAT IT DOES:
- Calculates risk score when new transaction added
- Updates user's risk_snapshots/latest document
- Creates alert if risk > 60

CODE:
```python
from firebase_functions import firestore_fn
from firebase_admin import firestore
import json
from datetime import datetime, timedelta

db = firestore.client()

def calculate_risk_features(transactions):
    """Calculate risk features from transaction list"""
    if not transactions:
        return {"score": 50, "factors": ["insufficient_data"]}
    
    amounts = [t.get('amount', 0) for t in transactions]
    categories = [t.get('category', 'unknown') for t in transactions]
    
    # Velocity features
    total_7d = sum(a for a, t in zip(amounts, transactions) 
                   if t.get('timestamp', datetime.now()) > datetime.now() - timedelta(days=7))
    total_30d = sum(a for a, t in zip(amounts, transactions) 
                    if t.get('timestamp', datetime.now()) > datetime.now() - timedelta(days=30))
    
    # Category analysis
    high_risk_cats = ['cash_advance', 'gambling', 'pawn']
    high_risk_count = sum(1 for c in categories if c in high_risk_cats)
    
    # Calculate score (0-100, higher = more risky)
    score = 30  # Base score
    
    if total_30d < -50000:  # High spending
        score += 20
    if high_risk_count > 0:
        score += 25
    if len(transactions) < 5:  # New user
        score += 10
    
    factors = []
    if total_30d < -50000:
        factors.append("high_monthly_spending")
    if high_risk_count > 0:
        factors.append("high_risk_transactions")
    if total_7d < total_30d / 4:  # Spending accelerating
        factors.append("spending_velocity_increasing")
    
    return {
        "score": min(100, max(0, score)),
        "factors": factors if factors else ["stable_pattern"],
        "total_7d": total_7d,
        "total_30d": total_30d
    }

@firestore_fn.on_document_created(document="users/{userId}/transactions/{txId}")
def on_transaction_create(event):
    user_id = event.params["userId"]
    
    # Get last 90 days of transactions
    txs_ref = db.collection('users').document(user_id).collection('transactions')
    cutoff = datetime.now() - timedelta(days=90)
    txs = txs_ref.where('timestamp', '>', cutoff).order_by('timestamp', direction='DESCENDING').stream()
    
    transactions = [t.to_dict() for t in txs]
    
    # Calculate risk
    risk = calculate_risk_features(transactions)
    
    # Update risk snapshot
    db.collection('users').document(user_id).collection('risk_snapshots').document('latest').set({
        'value': risk['score'],
        'factors': risk['factors'],
        'trend': 'up' if risk['score'] > 50 else 'down',
        'timestamp': firestore.SERVER_TIMESTAMP,
        'total_7d': risk.get('total_7d', 0),
        'total_30d': risk.get('total_30d', 0)
    })
    
    # Create alert if high risk
    if risk['score'] > 60:
        db.collection('users').document(user_id).collection('alerts').add({
            'title': 'High Financial Risk Detected',
            'message': f"Your risk score is {risk['score']}/100. {', '.join(risk['factors'])}",
            'severity': 'high' if risk['score'] > 75 else 'medium',
            'type': 'predictive',
            'acknowledged': False,
            'timestamp': firestore.SERVER_TIMESTAMP
        })
    
    return f"Updated risk for {user_id}: {risk['score']}"
DEPLOY: firebase deploy --only functions:on_transaction_create
FUNCTION 2: chat_stream (HTTP)
Path: functions/src/http/chat_stream.py
Endpoint: POST /chat_stream
WHAT IT DOES:
AI chatbot that responds to user queries
Uses rule-based responses (no OpenAI key needed for hackathon)
Returns streaming response
CODE:
Python
Copy
from firebase_functions import https_fn
from firebase_admin import firestore
import json
import re

db = firestore.client()

KNOWLEDGE_BASE = {
    "high_risk": "Your risk score is elevated. Consider: 1) Review recent large purchases, 2) Set up spending alerts, 3) Build emergency fund. Would you like specific tips?",
    "budget": "Try the 50/30/20 rule: 50% needs, 30% wants, 20% savings. Based on your data, you're spending heavily on {category}.",
    "savings": "Start with â‚¹5,000 emergency fund, then aim for 3 months expenses. You can do this!",
    "food_assistance": "Emergency food resources: 1) Local food banks, 2] Government ration schemes, 3) Community kitchens. I can help you find nearby options.",
    "default": "I understand you're asking about {topic}. Based on your financial profile, I recommend reviewing your recent transactions and setting up budget alerts."
}

@https_fn.on_request()
def chat_stream(req):
    if req.method != 'POST':
        return https_fn.Response('Method not allowed', status=405)
    
    try:
        data = req.get_json()
        user_id = data.get('userId')
        message = data.get('message', '').lower()
        tier = data.get('tier', 'consumer')
        
        # Get user context
        risk_doc = db.collection('users').document(user_id).collection('risk_snapshots').document('latest').get()
        risk_data = risk_doc.to_dict() or {}
        score = risk_data.get('value', 50)
        
        # Simple intent matching
        response = KNOWLEDGE_BASE['default']
        
        if any(w in message for w in ['risk', 'score', 'high', 'danger', 'worried']):
            response = KNOWLEDGE_BASE['high_risk']
            if score:
                response = f"Your current risk score is {score}/100. " + response
        
        elif any(w in message for w in ['budget', 'spending', 'save money', 'reduce']):
            response = KNOWLEDGE_BASE['budget'].format(category='dining out')
        
        elif any(w in message for w in ['savings', 'emergency fund', 'invest']):
            response = KNOWLEDGE_BASE['savings']
        
        elif any(w in message for w in ['food', 'hungry', 'groceries', 'eat', 'help']):
            response = KNOWLEDGE_BASE['food_assistance']
        
        else:
            topic = re.sub(r'[^\w\s]', '', message)[:30]
            response = KNOWLEDGE_BASE['default'].format(topic=topic)
        
        # Simulate streaming
        def generate():
            words = response.split()
            for word in words:
                yield f"data: {json.dumps({'token': word + ' '})}\n\n"
            yield f"data: {json.dumps({'done': True})}\n\n"
        
        return https_fn.Response(
            generate(),
            mimetype='text/event-stream',
            headers={'Cache-Control': 'no-cache', 'Connection': 'keep-alive'}
        )
        
    except Exception as e:
        return https_fn.Response(f"Error: {str(e)}", status=500)
DEPLOY: firebase deploy --only functions:chat_stream
FUNCTION 3: batch_analyze (HTTP)
Path: functions/src/http/batch_analyze.py
Endpoint: POST /batch_analyze
WHAT IT DOES:
Accepts CSV data from analyst dashboard
Returns risk scores for multiple clients
Queues for processing (simplified for hackathon)
CODE:
Python
Copy
from firebase_functions import https_fn
from firebase_admin import firestore
import json
import csv
import io
from datetime import datetime

db = firestore.client()

@https_fn.on_request()
def batch_analyze(req):
    if req.method != 'POST':
        return https_fn.Response('Method not allowed', status=405)
    
    try:
        data = req.get_json()
        analyst_id = data.get('analystId')
        csv_content = data.get('csv')  # Base64 or raw CSV string
        
        # Parse CSV
        csv_file = io.StringIO(csv_content)
        reader = csv.DictReader(csv_file)
        
        results = []
        for row in reader:
            client_id = row.get('client_id', 'unknown')
            # Simple risk calc based on provided data
            income = float(row.get('income', 0))
            expenses = float(row.get('expenses', 0))
            debt = float(row.get('debt', 0))
            
            # Basic risk formula
            risk = 30
            if expenses > income * 0.8:
                risk += 30
            if debt > income * 3:
                risk += 25
            
            results.append({
                'client_id': client_id,
                'risk_score': min(100, risk),
                'status': 'completed',
                'analyzed_at': datetime.now().isoformat()
            })
        
        # Store results for analyst
        batch_ref = db.collection('analysts').document(analyst_id).collection('batch_results').document()
        batch_ref.set({
            'results': results,
            'created_at': firestore.SERVER_TIMESTAMP,
            'total_clients': len(results)
        })
        
        return https_fn.Response(
            json.dumps({'success': True, 'batch_id': batch_ref.id, 'results': results}),
            mimetype='application/json'
        )
        
    except Exception as e:
        return https_fn.Response(
            json.dumps({'success': False, 'error': str(e)}),
            mimetype='application/json',
            status=500
        )
DEPLOY: firebase deploy --only functions:batch_analyze
FUNCTION 4: aggregate_metrics (SCHEDULED)
Path: functions/src/scheduled/aggregate_metrics.py
Trigger: Every 5 minutes (pubsub schedule)
WHAT IT DOES:
Aggregates portfolio metrics for B2B institutions
Updates institution dashboard data
CODE:
Python
Copy
from firebase_functions import scheduler_fn
from firebase_admin import firestore
from datetime import datetime, timedelta

db = firestore.client()

@scheduler_fn.on_schedule(schedule="every 5 minutes")
def aggregate_metrics(event):
    # Get all institutions
    institutions = db.collection('institutions').stream()
    
    for inst in institutions:
        inst_id = inst.id
        inst_ref = inst.reference
        
        # Get all linked users
        users = inst_ref.collection('users').stream()
        user_ids = [u.id for u in users]
        
        if not user_ids:
            continue
        
        # Aggregate risk scores
        total_risk = 0
        high_risk_count = 0
        critical_count = 0
        
        for uid in user_ids:
            risk_doc = db.collection('users').document(uid).collection('risk_snapshots').document('latest').get()
            if risk_doc.exists:
                score = risk_doc.to_dict().get('value', 50)
                total_risk += score
                if score > 70:
                    high_risk_count += 1
                if score > 85:
                    critical_count += 1
        
        avg_risk = total_risk / len(user_ids) if user_ids else 50
        
        # Update metrics
        inst_ref.collection('metrics').document('realtime').set({
            'average_risk': avg_risk,
            'total_customers': len(user_ids),
            'high_risk_count': high_risk_count,
            'critical_count': critical_count,
            'compliance_rate': 100 - (high_risk_count / len(user_ids) * 100) if user_ids else 100,
            'updated_at': firestore.SERVER_TIMESTAMP
        })
    
    return f"Aggregated {len(list(institutions))} institutions"
DEPLOY: firebase deploy --only functions:aggregate_metrics
REACT HOOKS (Replace Mock Data)
Create these files in frontend to replace mock data:
FILE 1: src/hooks/useRiskScore.ts
TypeScript
Copy
import { useEffect, useState } from 'react'
import { doc, onSnapshot } from 'firebase/firestore'
import { db } from '@/lib/firebase'
import { useAuth } from '@/contexts/AuthContext'

export function useRiskScore() {
  const { user } = useAuth()
  const [score, setScore] = useState<any>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    if (!user) return
    
    const unsub = onSnapshot(
      doc(db, 'users', user.uid, 'risk_snapshots', 'latest'),
      (doc) => {
        setScore(doc.data())
        setLoading(false)
      },
      (err) => {
        console.error('Risk score error:', err)
        setLoading(false)
      }
    )
    
    return unsub
  }, [user])

  return { score, loading }
}
FILE 2: src/hooks/useTransactions.ts
TypeScript
Copy
import { useEffect, useState } from 'react'
import { collection, query, orderBy, limit, onSnapshot } from 'firebase/firestore'
import { db } from '@/lib/firebase'
import { useAuth } from '@/contexts/AuthContext'

export function useTransactions(limitCount = 50) {
  const { user } = useAuth()
  const [transactions, setTransactions] = useState<any[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    if (!user) return
    
    const q = query(
      collection(db, 'users', user.uid, 'transactions'),
      orderBy('timestamp', 'desc'),
      limit(limitCount)
    )
    
    const unsub = onSnapshot(q, (snapshot) => {
      setTransactions(snapshot.docs.map(d => ({ id: d.id, ...d.data() })))
      setLoading(false)
    }, (err) => {
      console.error('Transactions error:', err)
      setLoading(false)
    })
    
    return unsub
  }, [user, limitCount])

  return { transactions, loading }
}
FILE 3: src/hooks/useAlerts.ts
TypeScript
Copy
import { useEffect, useState } from 'react'
import { collection, query, orderBy, onSnapshot, updateDoc, doc } from 'firebase/firestore'
import { db } from '@/lib/firebase'
import { useAuth } from '@/contexts/AuthContext'

export function useAlerts() {
  const { user } = useAuth()
  const [alerts, setAlerts] = useState<any[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    if (!user) return
    
    const q = query(
      collection(db, 'users', user.uid, 'alerts'),
      orderBy('timestamp', 'desc')
    )
    
    const unsub = onSnapshot(q, (snapshot) => {
      setAlerts(snapshot.docs.map(d => ({ id: d.id, ...d.data() })))
      setLoading(false)
    })
    
    return unsub
  }, [user])

  const acknowledgeAlert = async (alertId: string) => {
    if (!user) return
    await updateDoc(doc(db, 'users', user.uid, 'alerts', alertId), {
      acknowledged: true
    })
  }

  return { alerts, loading, acknowledgeAlert }
}
FILE 4: src/hooks/useChat.ts
TypeScript
Copy
import { useState } from 'react'
import { useAuth } from '@/contexts/AuthContext'

export function useChat() {
  const { user, tier } = useAuth()
  const [messages, setMessages] = useState<any[]>([])
  const [loading, setLoading] = useState(false)

  const sendMessage = async (text: string) => {
    if (!user) return
    
    const userMsg = { role: 'user', content: text, timestamp: new Date() }
    setMessages(prev => [...prev, userMsg])
    setLoading(true)

    try {
      const response = await fetch('https://us-central1-finguard-ai-55aec.cloudfunctions.net/chat_stream', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: user.uid,
          message: text,
          tier: tier || 'consumer'
        })
      })

      const reader = response.body?.getReader()
      let aiResponse = ''

      while (reader) {
        const { done, value } = await reader.read()
        if (done) break
        
        const text = new TextDecoder().decode(value)
        const lines = text.split('\n')
        
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.slice(6))
              if (data.token) {
                aiResponse += data.token
                setMessages(prev => {
                  const newMessages = [...prev]
                  const lastMsg = newMessages[newMessages.length - 1]
                  if (lastMsg?.role === 'assistant') {
                    lastMsg.content = aiResponse
                    return [...newMessages]
                  } else {
                    return [...newMessages, { role: 'assistant', content: aiResponse, timestamp: new Date() }]
                  }
                })
              }
            } catch (e) {}
          }
        }
      }
    } catch (error) {
      console.error('Chat error:', error)
    } finally {
      setLoading(false)
    }
  }

  return { messages, loading, sendMessage }
}
SEED DATA FOR DEMO
Create this file to populate demo data:
FILE: scripts/seedDemo.js
JavaScript
Copy
const { initializeApp } = require('firebase/app')
const { getAuth, createUserWithEmailAndPassword } = require('firebase/auth')
const { getFirestore, doc, setDoc, collection, addDoc, serverTimestamp } = require('firebase/firestore')

const firebaseConfig = {
  apiKey: "AIzaSyBJfoqX_5ghf0Ggqv8cfjUJwP8ar5zptuU",
  authDomain: "finguard-ai-55aec.firebaseapp.com",
  projectId: "finguard-ai-55aec",
  storageBucket: "finguard-ai-55aec.firebasestorage.app",
  messagingSenderId: "620744063106",
  appId: "1:620744063106:web:e2bbce46722bf73ee99c9b"
}

const app = initializeApp(firebaseConfig)
const auth = getAuth(app)
const db = getFirestore(app)

const categories = ['grocery', 'dining', 'transport', 'utilities', 'entertainment', 'shopping', 'healthcare']
const merchants = ['BigBasket', 'Swiggy', 'Uber', 'Electricity Board', 'Netflix', 'Amazon', 'Pharmacy', 'Salary']

async function seedUser(email, password, displayName, tier = 'consumer') {
  try {
    // Create auth user
    let userId
    try {
      const cred = await createUserWithEmailAndPassword(auth, email, password)
      userId = cred.user.uid
      console.log(`Created user: ${email} (${userId})`)
    } catch (err) {
      if (err.code === 'auth/email-already-in-use') {
        console.log(`User exists: ${email}`)
        return // Skip if exists
      }
      throw err
    }

    // Create profile
    await setDoc(doc(db, 'users', userId), {
      email,
      displayName,
      tier,
      createdAt: serverTimestamp()
    })

    // Generate 60 days of transactions
    const transactions = []
    let balance = 50000
    
    for (let i = 0; i < 60; i++) {
      const date = new Date()
      date.setDate(date.getDate() - i)
      
      // Salary every 30 days
      if (i % 30 === 0) {
        transactions.push({
          userId,
          amount: 75000,
          category: 'income',
          merchantName: 'Employer',
          timestamp: date,
          type: 'credit',
          description: 'Monthly salary'
        })
        balance += 75000
      }
      
      // Daily expenses (vary to create interesting patterns)
      const dailySpend = 1500 + Math.random() * 1000
      const category = categories[Math.floor(Math.random() * categories.length)]
      
      transactions.push({
        userId,
        amount: -Math.round(dailySpend),
        category,
        merchantName: merchants[Math.floor(Math.random() * merchants.length)],
        timestamp: date,
        type: 'debit',
        description: `${category} purchase`
      })
      balance -= dailySpend
      
      // Add some high-risk transactions for demo
      if (i === 5) {
        transactions.push({
          userId,
          amount: -5000,
          category: 'cash_advance',
          merchantName: 'ATM Withdrawal',
          timestamp: date,
          type: 'debit',
          riskFlag: true,
          description: 'Cash advance'
        })
      }
    }

    // Batch write transactions
    for (const tx of transactions) {
      await addDoc(collection(db, 'users', userId, 'transactions'), tx)
    }
    
    console.log(`Added ${transactions.length} transactions for ${email}`)
    
  } catch (error) {
    console.error(`Error seeding ${email}:`, error.message)
  }
}

async function main() {
  console.log('Seeding demo data...\n')
  
  // Demo consumer (high risk pattern)
  await seedUser('demo@finguard.ai', 'demo123456', 'Demo User', 'consumer')
  
  // Another consumer (stable)
  await seedUser('stable@finguard.ai', 'demo123456', 'Stable User', 'consumer')
  
  console.log('\nâœ… Seeding complete!')
  console.log('Login with:')
  console.log('  demo@finguard.ai / demo123456 (high risk)')
  console.log('  stable@finguard.ai / demo123456 (stable)')
  process.exit(0)
}

main()
Run: node scripts/seedDemo.js
DEPLOYMENT CHECKLIST
Before declaring victory:
[ ] All 4 functions deploy without errors
[ ] Functions appear in Firebase Console > Functions
[ ] React hooks import correctly (no TypeScript errors)
[ ] Login works and creates user document
[ ] Adding transaction triggers risk calculation
[ ] Risk score appears in consumer dashboard
[ ] Chatbot responds with streaming text
[ ] Alerts appear when risk > 60
DEPLOY COMMANDS:
firebase deploy --only functions
firebase deploy --only firestore:rules
TROUBLESHOOTING
Error: "Permission denied"
-> Check Firestore rules are deployed
-> Ensure user is authenticated
Error: "Function not found"
-> Check function name matches in code and deploy command
-> Verify region (us-central1)
Error: "Module not found"
-> Add to functions/requirements.txt:
firebase-functions
firebase-admin
Error: "CORS error" in browser
-> Ensure functions return proper headers (handled in code above)
PRIORITY ORDER (If Running Late)
MUST HAVE (Demo won't work without):
on_transaction_create (risk scoring)
useRiskScore hook (display score)
useTransactions hook (display data)
Seed script (demo data)
NICE TO HAVE:
5. chat_stream (can mock responses)
6. batch_analyze (analyst feature)
7. aggregate_metrics (institution feature)
CONTACT
If stuck on Antigravity:
Check their docs for Firebase connection
Use their "Test Function" feature before deploying
Logs are in Firebase Console > Functions > Logs
If stuck on Firebase:
Firebase Console > Functions > Logs shows errors
Local emulator: firebase emulators:start --only functions
GOOD LUCK! ðŸš€